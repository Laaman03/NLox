using System.Text;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Formatting;

if (args.Length != 1)
{
    Console.Error.WriteLine("Usage: generate-ast <output directory>");
    Environment.Exit(1);
}

var exprTypes = new SubClass[]
{
    new SubClass("Binary"   , "Expr Left, Token Op, Expr Right"),
    new SubClass("Grouping" , "Expr Expression"),
    new SubClass("Literal"  , "object Value"),
    new SubClass("Unary"    , "Token Op, Expr Right"),
    new SubClass("Variable" , "Token Name"),
};

var stmtTypes = new SubClass[]
{
    new SubClass("Expression"   , "Expr ExpressionValue"),
    new SubClass("Print"        , "Expr ExpressionValue"),
    new SubClass("Var"          , "Token Name, Expr Initializer"),
};

defineAst(args[0], "Expr", exprTypes);
defineAst(args[0], "Stmt", stmtTypes);


static void defineAst(string outDir, string baseClass, SubClass[] types)
{
    var baseClassDef = $@"public abstract class {baseClass}
{{
public abstract R Accept<R>(I{baseClass}Visitor<R> visitor);
}}";

    var subClassDefs = types.Select(c =>
    {
        var members = GetClassMembers(c.Members);
        var con = GetConstructorDef(c.Name, c.Members);

        return $@"public class {c.Name} : {baseClass}
{{
{GetClassMembers(c.Members)}
public override R Accept<R>(IVisitor<R> visitor) => visitor.Visit{c.Name}{baseClass}(this);
{GetConstructorDef(c.Name, c.Members)}
}}";
    });

    var classDefs = $@"// Autogenerated
using System;
using System.Collections.Generic;

namespace NLox.Lib
{{
public abstract class {baseClass}
{{
public abstract R Accept<R>(IVisitor<R> visitor);

{string.Join("\r\n", subClassDefs)}

{GetIVisitorDef(baseClass, types)}
}}
}}";

    using var writer = new StreamWriter($"{outDir}\\{baseClass}.cs");
    writer.Write(classDefs);
}




static string GetClassMembers(string members)
{
    var props = members.Split(", ").Select(m => $"public {m} {{ get; private init; }}");
    return string.Join("\r\n", props);
}

static string GetConstructorDef(string className, string properties)
{
    // Create list of (type, name) split properties
    var props = properties.Split(", ").Select(tn => tn.Split(' '));

    // Copy above list and lower the property name for constructor def
    var localProps = props.Select(tn => new string[] { tn[0], tn[1].ToLower() });

    // Join them back for a string for the constructor signature
    var lpString = string.Join(", ", localProps.Select(tn => $"{tn[0]} {tn[1]}"));

    // Zip up the previous lists to make up the constructor body
    var setters = props.Zip(localProps, (p, lp) => $"{p[1]} = {lp[1]};");

    return $@"public {className}({string.Join(", ", lpString)})
{{
{string.Join("\r\n", setters)}
}}";
}

static string GetIVisitorDef(string baseClass, SubClass[] exprs)
{
    var methods = exprs.Select(e => $"R Visit{e.Name}{baseClass}({e.Name} expr);");
    return $@"public interface IVisitor<R>
{{
{string.Join("\r\n", methods)}
}}";
}

record class SubClass(string Name, string Members);